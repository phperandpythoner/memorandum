%d 十进制格式,以有符号的方式打印
%hd 表示短整型格式
%x或%X 十六进制格式
%o 八进制格式
%c 字符格式声明
%f 浮点型格式
%s 字符串型格式
%p 指针格式
%u 以无符号的方式打印
%lu表示输出无符号长整型整数 (long unsigned)



******************* 基础知识 案例讲解******************
一、0 '\0' '0'的区别
0 和 '\0' 等价，'0' 为字符'0'，不是结束符，ASCII为48

二、
char a[] = {'a', 'b'};
char a[] = {'a', 'b', '0'};
printf("%s\n", a); //乱码，因为没有结束符

char a[10] = {'a', 'b'}; //后面自动补0
char a[10] = {'a', 'b' , 0};
char a[10] = {'a', 'b', '\0'};
printf("%s\n", a); //正常

char buf[] = "hello"; // 以字符串初始化，自动隐藏结束符 '\0'


三、字符常量
//不能改p指向内存，相当于 char const *p
//p是指向文字常量区的指针变量
char *p = "abc";

//可以改变数组元素，这是把"abc"拷贝到数组p2中
char p2[] = "abc";

p2 = "abc";//错误，不能赋值，数组名是常量
strcpy(p2, "abc"); //正确

四、const可以被修改，通过间接赋值修改
const int a = 10;
int *p = &a;
*p = 20;


*************************** 基础知识 (必须掌握) ************************
一、变量作用范围
1、普通局部变量
	//1、在{}定义的变量就是局部变量
    //2、只有执行到定义变量这个语句，系统才会分配变量空间
    //3、当离开{}，非static局部变量才释放
    //4、局部变量作用在{}，离开{}，无法使用变量
    //5、{}的普通局部变量，加不加auto关键字等价，普通局部变量也叫自动变量
    //6、不同的{}中，变量名可以一样，但使用时根据就近原则
	//7、普通局部变量初始化值是随机数
	
2、static局部变量
	//1、在{}定义的变量就是局部变量
    //2、static局部变量，是在编译阶段就已分配空间，函数没有调用之前就已经存在
    //3、当离开{}，static局部变量不会释放，只有程序结束，static变量才会释放
    //4、局部变量作用在{}，离开{}，无法使用变量
    //5、不同的{}中，变量名可以一样，但使用时根据就近原则
    //6、如果static局部变量不初始化，默认值为0
    //7、static局部变量初始化语句只执行一次，但可以多次赋值
    //8、static局部变量只能用常量初始化（注意）

普通局部变量和static局部变量的区别
1、内存分配和释放
a）、普通局部变量只有执行到定义这个语句时才分配空间，当离开{}时释放；static局部变量在编译阶段就分配空间（函数还没执行），在程序结束时释放
2、初始化
普通局部变量不初始化，值为随机数；static局部变量不初始化，值为0，初始化语句只执行一次，并且初始化值只能是常量

3、普通全局变量（外部链接）
	1、在{}外面（函数外面）定义的变量为全局变量
	2、定义了全局变量，任何地方都可以使用
	3、如果使用变量时，前面找不到次全局变量，需要重新声明，extern关键字
	4、全局变量不初始化，默认值为0
	5、声明只针对全明变量，不针对局部变量
	6、全局变量只能声明一次，可以多次调用
	7、全局变量在编译阶段就分配空间（函数还没有执行），当程序结束时自动释放空间

4、static全局变量（内部链接）
	1、static全局变量和普通全局变量的作用域不一样（文件作用域）
	2、extern关键字只用于普通全局变量
	3、普通全局变量，所有文件都可以使用，但需要声明
	4、static全局变量只能本文件使用，其他文件不能使用
	5、不同文件只能出现一个普通全局变量的定义
	6、一个文件只能有一个static全局变量的定义，不同文件间的static全局变量，就算名字一样，两个static全局变量也没有任何关系

5、普通函数和static函数的区别（文件作用域）
	1、所有文件只能有一次普通函数的定义；一个文件可以有一个static函数的定义
	2、普通函数在所有文件都可以调用，前提需要声明；static函数只能在定义的文件中使用

	
二、内存管理
1、在程序没有执行之前，有几个分区已经确定，虽然分区确定，但是没有加载内存，只有程序执行时才加载内存
text（代码区）：只读，存放函数
data：初始化的数据，全局变量，static变量，文字常量区（只读）
bss：没有初始化的数据，全局变量，static变量

当程序运行，加载内存，首先根据前面确定的分区（text，data，bss）先加载，然后额外加载两个区
text（代码区）：只读，存放函数
data：初始化的数据，全局变量，static变量，文字常量区（只读）
bss：没有初始化的数据，全局变量，static变量
stack（栈区）：普通全局变量，自动管理内存，先进后出的特点
heap（堆区）：手动申请空间，手动释放，整个程序结束，系统也自动回收，如果没有手动释放，程序也没有结束，这个堆区的空间不会自动释放


2、内存操作函数
	1、memset()
		功能：将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作。
		用法：void *memset(void *s, char ch, unsigned n);
		程序：
			int a;
			memset(&a, 0, sizeof(a)); //常用，用作清空变量值
	2、memcpy()
	3、memmove()
	4、memcmp()
	

三、文件操作
（一）概述：
FILE所有平台的名字都一样，FILE是一种结构类型，里面的成员功能一样，但不同平台成员的名称不一样
FILE *fp
1、fp指针，只调用了fopen()，在堆区分配空间，把地址返回给fp
2、fp指针不是指向文件，fp和文件关联，fp内部成员保存了文件状态
3、操作fp指针，不能直接操作，必须通过文件函数来操作fp指针
4、通过库函数操作fp指针，对文件的任何操作，fp里面的成员会相应的变化（系统自动完成）

（二）、文件分类
1、磁盘文件：存放在硬盘里的文件
	文本文件
	二进制文件
2、设备文件：如键盘、显示屏

（三）、文件操作流程
1、打开文件fopen()
2、读写文件
	1）按字符读写：fputc(),fgetc()
	2）按字符串（按行）读写文件:fgets(),fputs()
	3）文件结束判断:feof()
3、关闭文件：fclose()

（四）、文件指针
stdin  0 标准输入
stdout 1 标准输出
stderr 2 标准出错

（五）、文件末尾处理
1、如果是文本文件，可以通过-1(EOF)判断文件是否结尾
2、如果是二进制文件，不能以-1判断文件结尾
3、feof()判断文件是否结尾，任何文件都可以判断

feof(fp);//如果到文件尾，返回真
1、如果第一次没有对文件进行读操作，直接调用此函数，永远返回真
2、此函数必须先读，再调用feof()才有意义
3、调用此函数feof()光标不会自动往后移
4、必须读取后，才能判断是否结束，判断是读取的字符


******************* 字符编码 ******************
1、解决qt，如果使用标准c函数，如果有中文，必须是GBK编码
a)、头文件：#include <QTextCodec>
b)、定义一个全局变量 QTextCodec *codec
c)、构造函数内部初始化
	codec = QTextCodec::codecForName("GBK");
d)、gbk -> utf-8:codec->toUnicode();
e)、utf-8 -> gbk:codec->fromUnicode();


******************* Linux下常用命令 ******************
ulimit -a 查看栈区大小

which 命令 //查看命令所在位置


******************* 关键字 ******************
1 数据类型关键字
A.基本数据类型（5个）
void ：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果
char ：字符型类型数据，属于整型数据的一种
int ：整型数据，通常为编译器指定的机器字长
	int 占4字节
	short 占2字节
	long long 占8字节
float ：单精度浮点型数据，属于浮点数据的一种
double ：双精度浮点型数据，属于浮点数据的一种

B .类型修饰关键字（4个）
short ：修饰int，短整型数据，可省略被修饰的int。
long ：修饰int，长整形数据，可省略被修饰的int。
signed ：修饰整型数据，有符号数据类型
unsigned ：修饰整型数据，无符号数据类型

C .复杂类型关键字（5个）
struct ：结构体声明
union ：共用体声明
enum ：枚举声明
typedef ：声明类型别名
sizeof ：得到特定类型或特定类型变量的大小

D .存储级别关键字（6个）
auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配
static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部
register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数
extern ：指定对应变量为外部变量，即标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）
volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值

2 流程控制关键字
A .跳转结构（4个）
return ：用在函数体中，返回特定值（或者是void值，即不返回值）
continue ：结束当前循环，开始下一轮循环
break ：跳出当前循环或switch结构
goto ：无条件跳转语句

B .分支结构（5个）
if ：条件语句，后面不需要放分号
else ：条件语句否定分支（与if连用）
switch ：开关语句（多重分支语句）
case ：开关语句中的分支标记
default ：开关语句中的“其他”分支，可选。

C .循环结构（3个）
for：for循环结构，for(1;2;3)4;的执行顺序为1->2->4->3->2...循环，其中2为循环条件。在整个for循环过程中，表达式1只计算一次，表达式2和表达式3则可能计算多次，也可能一次也不计算。循环体可能多次执行，也可能一次都不执行。
do ：do循环结构，do 1 while(2); 的执行顺序是1->2->1...循环，2为循环条件
while ：while循环结构，while(1) 2; 的执行顺序是1->2->1...循环，1为循环条件


******************* 函数 ******************
printf()
scanf()
getchar()	输入字符函数
putchar()	输出字符函数
puts()	输出字符串函数 // 会自动换行
gets()	输入字符串函数

// 从stdin（代表标准输入，键盘），读取内容
// 原型  char *  fgets(char * s, int n,FILE *stream)
// 可以读取换行符
fgets()
fputs()

strcat()	字符串链接函数
strcpy() strncpy()	字符串复制函数
strcmp()	字符串比较函数
strlen()	字符串长度函数 //遇到\0结束
strlwr()	字符串转换小写函数
strupr()	字符串转换大写函数

c语言中，定义数组后可以用sizeof命令获得数组的长度

******************* 函数的声明和定义 ******************
分文件（多文件）
1、按功能分xxx.h xxx.c
xxx.c
	函数的定义
xxx.h
	函数的声明
	
多个文件中，不能出现同名函数（static除外）

同一个文件如何防止头文件多次包含（包含多次，只生效一次）
1、在.h文件头部加上
#pragma once

2、
#ifndef _FILENAME_H
#define _FILENAME_H

// 声明函数

#endif


*******进制知识******

说明：
1）正数不需要转码，负数需要转码
2）十进制站在原码角度，二进制、八进制、十六进制站在补码角度

原码求补码过程
1）最高位符号位，其他位就是二进制（原码）
2）在1）基础上，符号位不变，其他位取反（反码）
3）补码在2）基础上加1（补码）

列子：原码1010 0011，求补码
原码：1010 0011
反码：1101 1100
补码：1101 1101
1011101 = 93
1101 1101 = -93


补码求原码过程
1）最高位符号位，其他位就是二进制（补码）
2）求补码的反码，符号位不变，其他位取反（反码）
3）原码在2）基础上加1（原码）

列子；补码1110 0101，求原码
补码：1110 0101
反码：1001 1010
原码：1001 1011
11011 = 27
1001 1011 = -27

%x或%X 默认以4字节（32位）大小打印
例如：
int a = -123
原码：1000 0000 0000 0000 0000 0000 0111 1011
反码：1111 1111 1111 1111 1111 1111 1000 0100
补码：1111 1111 1111 1111 1111 1111 1000 0101
	  f    f    f     f   f    f    8    5

